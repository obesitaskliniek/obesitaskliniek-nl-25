import events from"./modules/core.events.mjs";import{isVisible}from"./modules/util.observe.mjs";import mediaInfo from"./modules/helper.media-info.mjs";export const NAME="scrollBarEmulator";function RAFThrottle(callback){let ticking=false;return(...args)=>{if(ticking)return;ticking=true;requestAnimationFrame(()=>{callback(...args);ticking=false})}}function disableSnapping(scrollElement){scrollElement.dataset.scrollSnapping="false"}function restoreSnapping(scrollElement){scrollElement.dataset.scrollSnapping=
"true"}function restoreSnappingGracefully(scrollElement){const {scrollWidth:scrollSize,scrollLeft:scrollPosition,offsetWidth:scrollerSize}=scrollElement;const snapItem=scrollElement.children[0];const gap=parseInt(window.getComputedStyle(snapItem.parentElement).columnGap,10)||0;const slideItemSize=snapItem.offsetWidth+gap;const closestSnap=Math.round(scrollPosition/slideItemSize);const tolerance=2;let timeout=null;function waitToRestoreSnapping(){clearTimeout(timeout);timeout=setTimeout(()=>{restoreSnapping(scrollElement);
scrollElement.removeEventListener("scroll",waitToRestoreSnapping)},scrollPosition%slideItemSize?150:0)}if(Math.abs(scrollPosition)<tolerance||Math.abs(scrollPosition+scrollerSize-scrollSize)<tolerance)scrollElement.removeEventListener("scroll",waitToRestoreSnapping);else{scrollElement.scrollTo({left:closestSnap*slideItemSize,behavior:"smooth"});scrollElement.addEventListener("scroll",waitToRestoreSnapping)}}const scrollContainers=new Map;export function setupScrollbarControl(controlElement){const targetId=
controlElement.dataset.scrollTarget;const action=controlElement.dataset.scrollAction||"forward";const smooth=controlElement.dataset.scrollSmooth!=="false";if(!targetId){console.warn(controlElement,"Control element missing data-scroll-target attribute");return}controlElement.addEventListener("click",e=>{e.preventDefault();handleScrollAction(targetId,action,smooth)});if(controlElement.tagName==="BUTTON")controlElement.addEventListener("keydown",e=>{if(e.key==="Enter"||e.key===" "){e.preventDefault();
handleScrollAction(targetId,action,smooth)}})}function handleScrollAction(targetId,action,smooth){const container=scrollContainers.get(targetId);if(!container){console.warn(`Scroll container with ID "${targetId}" not found`);return}const {element:scrollElement,isSnapping}=container;const {scrollWidth,clientWidth,scrollLeft}=scrollElement;const maxScroll=scrollWidth-clientWidth;let targetScroll;if(isSnapping){const children=Array.from(scrollElement.children);if(children.length===0)return;const firstChild=
children[0];const gap=parseInt(window.getComputedStyle(firstChild.parentElement).columnGap,10)||0;const slideItemSize=firstChild.offsetWidth+gap;const currentIndex=Math.round(scrollLeft/slideItemSize);switch(action){case "forward":case "next":const nextIndex=currentIndex+1>=children.length?0:currentIndex+1;targetScroll=nextIndex*slideItemSize;break;case "backward":case "prev":case "previous":const prevIndex=currentIndex<=0?children.length-1:currentIndex-1;targetScroll=prevIndex*slideItemSize;break;
case "first":targetScroll=0;break;case "last":targetScroll=(children.length-1)*slideItemSize;break;default:const index=parseInt(action,10);if(!isNaN(index)&&index>=0&&index<children.length)targetScroll=index*slideItemSize}}else{const scrollAmount=clientWidth*.8;switch(action){case "forward":case "next":targetScroll=scrollLeft+scrollAmount;if(targetScroll>=maxScroll)targetScroll=0;break;case "backward":case "prev":case "previous":targetScroll=scrollLeft-scrollAmount;if(targetScroll<=0)targetScroll=
maxScroll;break;case "first":targetScroll=0;break;case "last":targetScroll=maxScroll;break;default:const position=parseInt(action,10);if(!isNaN(position))targetScroll=Math.min(position,maxScroll)}}if(targetScroll!==undefined){if(isSnapping)disableSnapping(scrollElement);scrollElement.scrollTo({left:Math.max(0,Math.min(targetScroll,maxScroll)),behavior:smooth?"smooth":"auto"});if(isSnapping&&smooth)setTimeout(()=>{restoreSnapping(scrollElement)},500);else if(isSnapping)restoreSnapping(scrollElement)}}
export function controlScroll(targetId,action,smooth=true){handleScrollAction(targetId,action,smooth)}function getOrientation(scrollElement){let hasVerticalOverflow=scrollElement.scrollHeight>scrollElement.clientHeight;let hasHorizontalOverflow=scrollElement.scrollWidth>scrollElement.clientWidth;const isViewportElement=scrollElement===document.body||scrollElement===document.documentElement;if(isViewportElement){hasVerticalOverflow=scrollElement.scrollHeight>window.innerHeight;hasHorizontalOverflow=
scrollElement.scrollWidth>window.innerWidth}return hasVerticalOverflow&&!hasHorizontalOverflow?"vertical":hasVerticalOverflow&&hasHorizontalOverflow?"vertical":"horizontal"}export function setupFakeScrollbar(scrollElement){if(scrollElement.id)scrollContainers.set(scrollElement.id,{element:scrollElement,isSnapping:scrollElement.dataset.scrollSnapping==="true"});const ORIENTATION=getOrientation(scrollElement);const SNAPPING=scrollElement.dataset.scrollSnapping==="true";const scrollbarTrack=document.createElement("div");
scrollbarTrack.className=`fake-scrollbar align-self-stretch fake-scrollbar-${ORIENTATION}`;const scrollbarThumb=document.createElement("div");scrollbarThumb.className="fake-scrollbar-thumb";scrollbarTrack.appendChild(scrollbarThumb);scrollElement.parentNode.insertBefore(scrollbarTrack,scrollElement.nextSibling);const cssSScrollStyle=ORIENTATION==="horizontal"?window.getComputedStyle(scrollElement).overflowX:window.getComputedStyle(scrollElement).overflowY;if(cssSScrollStyle==="hidden"){scrollbarTrack.style.visibility=
"hidden";return}function updateSelf(){let totalSize,visibleSize,scrollPosition,maxScroll,overflow=false;if(ORIENTATION==="horizontal")({scrollWidth:totalSize,clientWidth:visibleSize,scrollLeft:scrollPosition}=scrollElement);else({scrollHeight:totalSize,clientHeight:visibleSize,scrollTop:scrollPosition}=scrollElement);visibleSize=scrollElement===document.body||scrollElement===document.documentElement?window.innerHeight:visibleSize;maxScroll=totalSize-visibleSize;overflow=visibleSize<=totalSize;scrollbarThumb.style.visibility=
!overflow?"hidden":"";scrollbarTrack.style.visibility=!overflow?cssSScrollStyle==="auto"?"hidden":"":"";if(maxScroll<=0||!overflow){scrollbarTrack.style.setProperty("--scrollbar-thumb-size","0px");return}const thumbSize=Math.round(visibleSize/totalSize*visibleSize);const thumbPosition=Math.round(scrollPosition/maxScroll*(visibleSize-thumbSize)*10)/10;const newStyles={};scrollbarTrack.style.setProperty("--scrollbar-thumb-size",`${thumbSize}px`);scrollbarTrack.style.setProperty("--scrollbar-thumb-position",
`${thumbPosition}px`)}const updateScrollbar=RAFThrottle(updateSelf);eventHandler.addListener("docShift",updateScrollbar);scrollElement.addEventListener("scroll",updateScrollbar,{passive:true});function handlePointerUp(el,pointerId,moveFn,upFn,snapping){if(snapping)restoreSnappingGracefully(scrollElement);scrollElement.style.scrollBehavior="";scrollElement.classList.remove("being-scrolled","grabbed-scrollbar");el.releasePointerCapture(pointerId);el.removeEventListener("pointermove",moveFn);el.removeEventListener("pointerup",
upFn);el.removeEventListener("pointercancel",upFn)}function bindMoveEvents(el,move,cancel){el.addEventListener("pointermove",move);el.addEventListener("pointerup",cancel);el.addEventListener("pointercancel",cancel)}scrollbarTrack.addEventListener("pointerdown",downEvt=>{downEvt.preventDefault();if(SNAPPING)disableSnapping(scrollElement);scrollElement.style.scrollBehavior="auto";scrollElement.classList.add("being-scrolled");scrollElement.classList.add("grabbed-scrollbar");const startX=downEvt.clientX;
let startScroll=scrollElement.scrollLeft;const {scrollWidth,clientWidth}=scrollElement;const trackRect=scrollbarTrack.getBoundingClientRect();const thumbRect=scrollbarThumb.getBoundingClientRect();const maxScroll=scrollWidth-clientWidth;const maxThumbOffset=trackRect.width-thumbRect.width;if(scrollbarTrack===downEvt.target){scrollElement.dataset.scrollSnapping="false";const clickX=downEvt.clientX-trackRect.left;const halfThumb=thumbRect.width/2;const thumbOff=Math.min(Math.max(clickX-halfThumb,0),
maxThumbOffset);const newScroll=thumbOff/maxThumbOffset*maxScroll;scrollElement.scrollLeft=startScroll=newScroll}const track=downEvt.currentTarget;track.setPointerCapture(downEvt.pointerId);function onPointerMove(moveEvt){const deltaX=moveEvt.clientX-startX;const thumbPos=Math.min(Math.max(startScroll/maxScroll*maxThumbOffset+deltaX,0),maxThumbOffset);scrollElement.scrollLeft=thumbPos/maxThumbOffset*maxScroll}function onPointerUp(upEvt){handlePointerUp(track,upEvt.pointerId,onPointerMove,onPointerUp,
SNAPPING)}bindMoveEvents(track,onPointerMove,onPointerUp)});if(scrollElement.dataset.draggable==="true"&&window.PointerEvent)scrollElement.addEventListener("pointerdown",contentPointerDown,{passive:false});function contentPointerDown(e){if(e.pointerType!=="mouse")return;const origTgt=e.composedPath?e.composedPath()[0]:e.target;if(!(origTgt instanceof Element))return;const control=origTgt.closest("a, button");if(control)return;e.preventDefault();if(SNAPPING)disableSnapping(scrollElement);scrollElement.style.scrollBehavior=
"auto";scrollElement.classList.add("being-scrolled");const startX=e.clientX;const startScroll=scrollElement.scrollLeft;scrollElement.setPointerCapture(e.pointerId);function onMove(moveEvt){const deltaX=moveEvt.clientX-startX;scrollElement.scrollLeft=startScroll-deltaX}function onUp(upEvt){handlePointerUp(scrollElement,upEvt.pointerId,onMove,onUp,SNAPPING)}bindMoveEvents(scrollElement,onMove,onUp)}if(scrollElement.dataset.autoscroll==="true"&&!mediaInfo("prefers-reduced-motion")){const interval=Math.max(1E3,
+scrollElement.dataset.interval||1E4);const children=Array.from(scrollElement.children);let timerId=null;let waitTimer=null;function getNextChildIndex(){const currentChildIndex=children.indexOf(children.find(child=>child.offsetLeft+child.offsetWidth>scrollElement.scrollLeft));return currentChildIndex+1<=children.length?currentChildIndex+1:0}function go(){clearInterval(timerId);timerId=setInterval(()=>{isVisible(scrollElement,function(visible){if(visible&&scrollElement.dataset.autoscroll==="true"){const reachedEnd=
Math.abs(scrollElement.scrollLeft+scrollElement.offsetWidth-scrollElement.scrollWidth)<10;scrollElement.scrollLeft=reachedEnd?0:children[getNextChildIndex()].offsetLeft}})},interval)}[scrollElement,scrollbarTrack].forEach(el=>{["pointerdown","wheel","touchstart","mouseenter","keydown"].forEach(evt=>el.addEventListener(evt,()=>{clearInterval(timerId)},{passive:true}));["mouseleave"].forEach(evt=>el.addEventListener(evt,()=>{clearInterval(waitTimer);waitTimer=setTimeout(go,interval)},{passive:true}))});
eventHandler.addListener("docShift",()=>{isVisible(scrollElement,function(visible){if(!timerId&&!visible){clearInterval(waitTimer);waitTimer=setTimeout(go,interval)}})});go()}updateScrollbar()};
