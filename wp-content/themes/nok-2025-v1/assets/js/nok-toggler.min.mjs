import{singleClick}from"./domule/modules/hnl.clickhandlers.mjs";import{logger}from"./domule/core.log.mjs";import{debounceThis,debouncedEvent}from"./domule/modules/hnl.debounce.mjs";export const NAME="simpleToggler";const TRIGGER_SELECTOR="[data-toggles-class],[data-toggles-attribute],"+"[data-sets-class],[data-sets-attribute],"+"[data-unsets-class],[data-unsets-attribute]";const EVENT_HOVER="pointerenter";const EVENT_CLICK="click";const EVENT_POINTERMOVE="pointermove";const RESTORE_UNSET="unset";
const RESTORE_SET="set";const MASK_TAG="nok-screen-mask";const SUPPORTS_HOVER=window.matchMedia("(hover: hover)").matches;const SWIPE_THRESHOLD=50;const SWIPE_VELOCITY=.3;function clamp(value,min,max){return Math.min(Math.max(value,min),max)}function createSwipeHandler(element,onSwipe,direction="y",threshold=SWIPE_THRESHOLD,velocity=SWIPE_VELOCITY){let start=0,current=0,isDragging=false,animationFrame=null;const clamp=(v,mn,mx)=>Math.min(mx,Math.max(mn,v));const getCoords=e=>e.touches?.[0]||e.changedTouches?.[0]||
e;const axis=direction==="y"?"clientY":"clientX";const getMin=()=>direction==="y"?-element.clientHeight:-element.clientWidth;const getMax=()=>0;const updateTransform=delta=>{if(animationFrame)return;animationFrame=requestAnimationFrame(()=>{element.style.transform=direction==="x"?`translate3d(${clamp(delta,getMin(),getMax())}px, 0, 0)`:`translate3d(0, ${clamp(delta,getMin(),getMax())}px, 0)`;animationFrame=null})};const drag=e=>{current=getCoords(e)[axis];isDragging=current!==start;if(!isDragging)return;
e.preventDefault();element.style.userSelect="none";element.style.transition="none";updateTransform(current-start)};const pointerUp=()=>{if(animationFrame){cancelAnimationFrame(animationFrame);animationFrame=null}if(isDragging){const distanceMoved=Math.abs(start-current);const timeTaken=Date.now()-startTime;const gestureVelocity=distanceMoved/timeTaken;const shouldTrigger=distanceMoved>threshold&&gestureVelocity>velocity;element.style.transition="transform 0.25s ease-out";element.addEventListener("transitionend",
()=>{element.style.userSelect="";element.style.transition="";element.style.transform=""},{once:true});element.style.transform=shouldTrigger?"":"translate3d(0, 0, 0)";if(shouldTrigger)onSwipe()}cleanup();isDragging=false};let startTime=0;const pointerDown=e=>{isDragging=false;start=getCoords(e)[axis];startTime=Date.now();document.addEventListener("pointermove",drag,{passive:false});document.addEventListener("pointerup",pointerUp,{passive:true})};const cleanup=()=>{document.removeEventListener("pointermove",
drag);document.removeEventListener("pointerup",pointerUp)};element.addEventListener("pointerdown",pointerDown);return()=>{element.removeEventListener("pointerdown",pointerDown);cleanup();if(animationFrame)cancelAnimationFrame(animationFrame)}}const triggerControllers=new WeakMap;const swipeCleanups=new WeakMap;const autoRestoreTimeouts=new WeakMap;export function init(elements){elements.forEach(element=>{if(!(element instanceof Element))return;try{if(element.matches(TRIGGER_SELECTOR))createToggleHandler(element);
element.querySelectorAll(TRIGGER_SELECTOR).forEach(toggler=>{createToggleHandler(toggler)})}catch(error){logger.error(NAME,"Error initializing togglers");logger.error(NAME,error)}})}export function destroy(){logger.info(NAME,"Cleanup initiated (controllers will be garbage collected)")}function createToggleHandler(trigger){const dataset=trigger.dataset;const triggerEvent=dataset.toggleEvent==="hover"?EVENT_HOVER:EVENT_CLICK;const restoreState=dataset.toggleOutside??null;const swipeRestore=dataset.swipe===
RESTORE_UNSET;const autoRestore=dataset.autoRestore?parseInt(dataset.autoRestore,10)*1E3:null;const targets={class:dataset.classTarget??dataset.target??null,attr:dataset.attributeTarget??null};if(!targets.class&&!targets.attr){logger.warn(NAME,"Element has no targets, skipping");logger.warn(NAME,trigger);return}const actions={toggle:{class:dataset.togglesClass?.split(",")??null,attr:[dataset.togglesAttribute??null,dataset.togglesAttributeValue??null]},add:{class:dataset.setsClass?.split(",")??null,
attr:[dataset.setsAttribute??null,dataset.setsAttributeValue??null]},remove:{class:dataset.unsetsClass?.split(",")??null,attr:[dataset.unsetsAttribute??null,dataset.unsetsAttributeValue??null]}};trigger.addEventListener(triggerEvent,e=>{e.preventDefault();handleTriggerEvent(e,trigger,dataset,actions,targets,restoreState,swipeRestore,autoRestore,triggerEvent)},{passive:false})}function handleTriggerEvent(e,trigger,dataset,actions,targets,restoreState,swipeRestore,autoRestore,triggerEvent){if(dataset.noChildren&&
e?.target!==trigger&&trigger.contains(e?.target))return;const existingController=triggerControllers.get(trigger);if(existingController){cleanupController(existingController);existingController.abort()}const controller=new AbortController;triggerControllers.set(trigger,controller);let tgtElementsArray=[];let undoStack=[];for(const [method,types]of Object.entries(actions))for(const [actionType,value]of Object.entries(types)){if(!value||Array.isArray(value)&&value.every(v=>!v))continue;const targetSelector=
targets[actionType];if(!targetSelector)continue;const targetElements=document.querySelectorAll(targetSelector);if(targetElements.length===0)continue;tgtElementsArray=[...tgtElementsArray,...Array.from(targetElements)];const undoOps=executeAction(targetElements,actionType,method,value,restoreState);undoStack.push(...undoOps)}if(swipeRestore&&tgtElementsArray.length>0)setupSwipeRestore(tgtElementsArray,undoStack,controller);if(restoreState)setupRestoreBehavior(trigger,tgtElementsArray,undoStack,controller,
triggerEvent);if(autoRestore)setupAutoRestore(undoStack,controller,autoRestore);if(swipeRestore&&tgtElementsArray.length>0)setupSwipeRestore(tgtElementsArray,undoStack,controller);if(restoreState)setupRestoreBehavior(trigger,tgtElementsArray,undoStack,controller,triggerEvent)}function executeAction(targetElements,actionType,method,value,restoreState){const undoOps=[];if(actionType==="class")targetElements.forEach(el=>{const result=el.classList[method](...value);let undoMethod;if(restoreState===RESTORE_UNSET)undoMethod=
"remove";else if(method==="toggle")undoMethod=result?"remove":"add";else if(method==="add")undoMethod="remove";else undoMethod="add";undoOps.push({target:el.classList,method:undoMethod,value:value})});else if(actionType==="attr")targetElements.forEach(target=>{const attrName=value[0];const attrValue=value[1];const hasAttribute=target.hasAttribute(attrName);const shouldRemove=method==="remove"||method==="toggle"&&hasAttribute;if(shouldRemove){const oldValue=target.getAttribute(attrName);target.removeAttribute(attrName);
if(restoreState!==RESTORE_SET)undoOps.push({target,method:"setAttribute",value:[attrName,oldValue]})}else{target.setAttribute(attrName,attrValue);if(restoreState!==RESTORE_UNSET)undoOps.push({target,method:"removeAttribute",value:[attrName]})}});return undoOps}function setupSwipeRestore(targetElements,undoStack,controller){const cleanupFunctions=[];function handleSwipe(){executeUndoStack(undoStack);cleanupController(controller);controller.abort()}targetElements.forEach(element=>{const cleanup=createSwipeHandler(element,
handleSwipe);cleanupFunctions.push(cleanup)});swipeCleanups.set(controller,cleanupFunctions)}function setupAutoRestore(undoStack,controller,delay){const timeoutId=setTimeout(()=>{executeUndoStack(undoStack);cleanupController(controller);controller.abort()},delay);autoRestoreTimeouts.set(controller,timeoutId)}function setupRestoreBehavior(trigger,targetElements,undoStack,controller,triggerEvent){function checkOutsideInteraction(e){const isSelf=e?.target===trigger||trigger.contains(e?.target);const isTarget=
targetElements.some(node=>node===e?.target||node.contains(e?.target));const isMask=e?.target?.tagName?.toLowerCase()===MASK_TAG;if(!isSelf&&!isTarget||isMask){executeUndoStack(undoStack);cleanupController(controller);controller.abort()}}if(triggerEvent===EVENT_HOVER)document.body.addEventListener(EVENT_POINTERMOVE,debounceThis(checkOutsideInteraction,{execWhile:true,execDone:false}),{signal:controller.signal});else document.body.addEventListener(EVENT_CLICK,checkOutsideInteraction,{signal:controller.signal})}
function executeUndoStack(undoStack){undoStack.forEach(operation=>{const {target,method,value}=operation;if(method==="setAttribute")target.setAttribute(...value);else if(method==="removeAttribute")target.removeAttribute(...value);else target[method](...value)})}function cleanupController(controller){const cleanupFunctions=swipeCleanups.get(controller);if(cleanupFunctions){cleanupFunctions.forEach(cleanup=>cleanup());swipeCleanups.delete(controller)}const timeoutId=autoRestoreTimeouts.get(controller);
if(timeoutId){clearTimeout(timeoutId);autoRestoreTimeouts.delete(controller)}};
